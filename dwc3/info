#!/usr/bin/perl

use strict;

description("Print information about the controller");
run_as_root();

sub usage {
    my $exit_code = shift;

    print <<USAGE_EOF;
usage: $SCRIPT [eps] | [ep_name [trb_ring]]

Show current controller status and its
endpoints debug info.

Options:
  <NONE>     - print current controller status
  eps        - list all controller's endpoint info
  ep_name    - endpoint name e.g. ep1in, ep2out
  trb_ring   - print endpoint TRB ring of an endpoint

USAGE_EOF

    exit $exit_code;
}

sub print_status {
    my $snpsid = shift;
    my $GDBGLTSSM;
    my $rtl_ver;

    my $ver_num = rreg(0xc1a0);
    my $ver_num_ascii = pack "N*", $ver_num;
    $ver_num_ascii =~ s/(\d)(.*?)\*?$/$1.$2a/;

    if ($snpsid == 0x3331) {
        $GDBGLTSSM = rreg(0xd050);
        my $ver_type = rreg(0xc1a4);
        my $ver_type_ascii = pack "N*", $ver_type;
        $rtl_ver = "$ver_num_ascii-$ver_type_ascii";
    } else {
        $GDBGLTSSM = rreg(0xc164);
        $rtl_ver = "$ver_num_ascii";
    }

    my $GHWPARAMS0 = rreg(0xc140);
    my $hw_mode = ($GHWPARAMS0 & 0x3);

    my $hw_mode_name;
    if ($hw_mode == 0) { $hw_mode_name = "device" }
    elsif ($hw_mode == 1) { $hw_mode_name = "host" }
    elsif ($hw_mode == 2) { $hw_mode_name = "drd" }

    # Find device speed
    my $DSTS = rreg(0xc70c);
    my $lane = ($DSTS & (1 << 30)) ? "2-lane" : "1-lane";
    my $speed_num = $DSTS & 7;

    my $speed;
    if ($speed_num == 4) { $speed = "Super speed gen1 $lane"; }
    elsif ($speed_num == 5) { $speed = "Super speed gen2 $lane"; }
    elsif ($speed_num == 0) { $speed = "High speed"; }
    elsif ($speed_num == 1) { $speed = "Full speed"; }
    elsif ($speed_num == 2) { $speed = "Low speed"; }
    elsif ($speed_num == 3) { $speed = "Full speed"; }
    else { $speed = "Unknown"; }

    my $num = $GDBGLTSSM;
    $num = $num & 0x03C00000;
    $num = ($num >> 22) ;

    my $state;
    if ($speed_num < 4) {
    if ($num == 0) { $state = "On"; }
        elsif ($num == 2) { $state = "Sleep L1"; }
        elsif ($num == 3) { $state = "Suspend L2"; }
        elsif ($num == 4) { $state = "Disconnected"; }
        elsif ($num == 5) { $state = "Early Suspend"; }
        elsif ($num == 14) { $state = "Reset"; }
        elsif ($num == 15) { $state = "Resume"; }
        else { $state = "Unknown"; }
    } else {
        if ($num == 0) { $state = "U0"; }
        elsif ($num == 1) { $state = "U1"; }
        elsif ($num == 2) { $state = "U2"; }
        elsif ($num == 3) { $state = "U3"; }
        elsif ($num == 4) { $state = "SS_disable"; }
        elsif ($num == 5) { $state = "Rx_Detect "; }
        elsif ($num == 6) { $state = "SS_Inactive"; }
        elsif ($num == 7) { $state = "Poll"; }
        elsif ($num == 8) { $state = "Recov"; }
        elsif ($num == 9) { $state = "HReset"; }
        elsif ($num == 10) { $state = "Compliance"; }
        elsif ($num == 11) { $state = "Loopback"; }
        else { $state = "Unknown"; }
    }
    my $link_state = sprintf "0x%02x", $num;

    $num = $GDBGLTSSM & 0x3C0000;
    my $sublink_state = sprintf "0x%02x", $num >> 18;

    #Find MPHY state
    my $GUSB3RMMICTL = rreg(0xc1c0);
    $num = ($GUSB3RMMICTL & 0x0E000000) >> 25;
    my $mphy_state_num = $num;

    my $mphy_state;

    if ($num == 0) { $mphy_state = "disable"; }
    elsif ($num == 1) { $mphy_state = "hibern8"; }
    elsif ($num == 2) { $mphy_state = "sleep  "; }
    elsif ($num == 3) { $mphy_state = "STALL"; }
    elsif ($num == 4) { $mphy_state = "PWM_burst"; }
    elsif ($num == 5) { $mphy_state = "HS-BURST"; }
    elsif ($num == 6) { $mphy_state = "line_cfg"; }
    elsif ($num == 7) { $mphy_state = "line_reset"; }
    else { $mphy_state = "Unknown"; }

    print <<"DWC_INFO"
    RTL Version:   $rtl_ver
    HW Mode:       $hw_mode_name
    LinkState:     $state ($link_state)
    Sub LinkState: $sublink_state
    Speed:         $speed
    GUSB3RMMICTL:  $GUSB3RMMICTL
    MPHY State:    $mphy_state ($mphy_state_num)

DWC_INFO
}

sub print_ep {
    my $debugfs = shift;
    my $ep = shift;

    my $desc_fetch_q;
    my $event_q;
    my $rx_info_q;
    my $tx_info_q;
    my $rx_fifo_q;
    my $tx_fifo_q;

    cmd("cat $debugfs/$ep/descriptor_fetch_queue", \$desc_fetch_q);
    cmd("cat $debugfs/$ep/event_queue", \$event_q);
    cmd("cat $debugfs/$ep/rx_fifo_queue", \$rx_fifo_q);
    cmd("cat $debugfs/$ep/tx_fifo_queue", \$tx_fifo_q);
    cmd("cat $debugfs/$ep/rx_info_queue", \$rx_info_q);
    #cmd("cat $debugfs/$ep/tx_info_queue", \$tx_info_q);

    chomp $event_q;
    chomp $event_q;
    chomp $rx_fifo_q;
    chomp $tx_fifo_q;
    chomp $rx_info_q;
    chomp $tx_info_q;

    print <<EP_INFO;
## $ep
desc_fetch_queue = $event_q
event_queue      = $event_q
rx_fifo_queue    = $rx_fifo_q
tx_fifo_queue    = $tx_fifo_q
rx_info_queue    = $rx_info_q
=============================
EP_INFO
}

sub main {
    # Check if PCIe device is in PCI bus
    base();

    # Check if device ID is correct
    my $snpsid = rreg(0xc120) >> 16;
    if (($snpsid != 0x5533) && ($snpsid != 0x3331)) {
        die sprintf("Error: Wrong device ID %04x\n", $snpsid);
    }

    if (!@ARGV) {
        print "\n";

        print_status($snpsid);
        exit(0);
    } else {
        my $debugfs;

        if ($TYPE eq "dwc3") {
            $debugfs = dwc3_debugfs() or die("No debugfs for $TYPE");
        } else {
            die("Endpoint debug is unsupported for $TYPE");
        }

        if ($ARGV[0] eq "eps") {
            my @eps;
            my @files = <"$debugfs/*">;

            foreach my $file (@files) {
                my $name;

                if ($file =~ /(ep\d{1,2}(?:in|out))/) {
                    push @eps, $1;
                }
            }

            foreach my $ep (@eps) {
                print_ep($debugfs, $ep);
            }
        } elsif ($ARGV[0] =~ /(ep\d{1,2}(?:in|out))/) {
            my $ep = shift @ARGV;

            if ($ARGV[0] eq 'trb_ring') {
                cmd("cat $debugfs/$ep/trb_ring");
            } else {
                print_ep($debugfs, $ep);
            }
        } else {
            usage(0);
        }
    }

    exit(0);
}

main();
